<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ONNX to Mabor: Development Guide - The Mabor Contributor Book 🔥</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async="" src="../../../ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Mabor Contributor Book 🔥</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="onnx-to-burn-development-guide"><a class="header" href="#onnx-to-burn-development-guide">ONNX to Burn: Development Guide</a></h1>
<p>This guide offers in-depth design insights and step-by-step procedures for developers working on the
ONNX to Mabor conversion tool. This tool allows the importation of ONNX models into the Mabor deep
learning framework written in Rust. It converts both ONNX models to Rust source code and model
weights to Mabor state files.</p>
<p>For an introduction to ONNX import in Mabor, see
<a href="../../burn/import/onnx-model.html">this section of the Mabor book</a>.</p>
<h2 id="design-overview"><a class="header" href="#design-overview">Design Overview</a></h2>
<h3 id="design-goals"><a class="header" href="#design-goals">Design Goals</a></h3>
<ul>
<li>Perform best-effort conversion of ONNX models to Rust source code via Mabor APIs.</li>
<li>Convert ONNX model weights to Mabor state files.</li>
<li>Support ONNX models generated by PyTorch (ONNX Opset 16).</li>
<li>Produce easy-to-understand and modifiable models.</li>
<li>Ensure the generated models are trainable using Mabor APIs.</li>
</ul>
<h3 id="design-decisions"><a class="header" href="#design-decisions">Design Decisions</a></h3>
<ul>
<li>Limit interaction with ONNX to the Intermediate Representation (IR) stage to simplify the process.</li>
<li>Ensure operator behavior consistency across different OpSet versions.</li>
<li>Exclude any ONNX/Protobuf-specific logic from the Mabor graph.</li>
</ul>
<p>The conversion process involves three main stages:</p>
<ol>
<li>Convert ONNX model to Intermediate Representation (IR).</li>
<li>Translate IR to a Mabor graph.</li>
<li>Generate Rust source code from the Mabor graph.</li>
</ol>
<h2 id="adding-new-operators"><a class="header" href="#adding-new-operators">Adding New Operators</a></h2>
<p>To extend <code>mabor-import</code> with support for new ONNX operators, follow these steps:</p>
<ol>
<li>
<p><strong>Create PyTorch Script</strong>: Place a PyTorch script using the new operator under
<code>crates/mabor-import/onnx-tests/tests/&lt;op&gt;/&lt;op&gt;.py</code>. Make sure to print both input and output
tensors for end-to-end testing.</p>
</li>
<li>
<p><strong>Generate ONNX Model</strong>: Run the PyTorch script to produce an ONNX model.</p>
</li>
<li>
<p><strong>Visualize ONNX Model</strong>: Use <a href="https://github.com/lutzroeder/netron">Netron</a> to verify the ONNX
model contains the expected operators.</p>
</li>
<li>
<p><strong>Generate IR and Mabor Graph</strong>: Navigate to
<a href="https://github.com/tracel-ai/burn/tree/main/crates/burn-import">crates/mabor-import/</a> and run:</p>
<pre><code>cargo r -- ./onnx-tests/tests/&lt;op&gt;/&lt;op&gt;.onnx ./out
</code></pre>
</li>
<li>
<p><strong>Implement Missing Operators</strong>: If you encounter an error stating that an operator is
unsupported, <a href="#implementing-a-new-operator">implement it</a>. The <code>./out/my-model.graph.txt</code> should
provide relevant information.</p>
</li>
<li>
<p><strong>Inspect Generated Files</strong>: The <code>my-model.graph.txt</code> contains IR details, <code>my-model.rs</code> holds
the Mabor model in Rust code, and <code>my-model.json</code> includes the model data.</p>
</li>
<li>
<p><strong>Add End-to-End Test</strong>: Include the test in
<a href="https://github.com/tracel-ai/burn/blob/main/crates/burn-import/onnx-tests/tests/test_onnx.rs">crates/mabor-import/onnx-tests/tests/test_onnx.rs</a>.
Further details can be found in the
<a href="https://github.com/tracel-ai/burn/blob/main/crates/burn-import/onnx-tests/README.md">onnx-tests README</a>.</p>
</li>
</ol>
<h2 id="implementing-a-new-operator"><a class="header" href="#implementing-a-new-operator">Implementing a New Operator</a></h2>
<p>To extend the capabilities of the Mabor library by supporting new operations imported from ONNX
graphs, developers must go through a few systematic steps. Here, we detail the process, using the
implementation of the <code>Squeeze</code> operation to illustrate points as needed. All file/directory paths
are relative to the root of the mabor repository.</p>
<h3 id="step-1-visibility"><a class="header" href="#step-1-visibility">Step 1: Visibility</a></h3>
<p>To make a new operation accessible, there are two key modules to update:</p>
<ol>
<li>In <code>crates/onnx-ir/src/node/mod.rs</code>, add your new operation module to make it visible within the
IR</li>
<li>In <code>crates/mabor-import/src/mabor/node/mod.rs</code>, make the corresponding node type visible within
mabor-import</li>
</ol>
<h3 id="step-2-node-implementation"><a class="header" href="#step-2-node-implementation">Step 2: Node Implementation</a></h3>
<h4 id="within-onnx-ir"><a class="header" href="#within-onnx-ir">Within onnx-ir</a></h4>
<p>The <code>onnx-ir</code> crate handles the Intermediate Representation (IR) of ONNX models. For each operation:</p>
<ol>
<li>
<p>Add the operation to the <code>NodeType</code> enum in <code>crates/onnx-ir/src/ir.rs</code>.</p>
</li>
<li>
<p>Create a new module file in <code>crates/onnx-ir/src/node/&lt;operation_name&gt;.rs</code>. This file should
include:</p>
<ul>
<li>A <code>&lt;operation_name&gt;_config</code> function to extract operation parameters</li>
<li>A <code>&lt;operation_name&gt;_update_output</code> function for dimension inference</li>
</ul>
</li>
<li>
<p>If the operation might work with constants, add it to the list of node types checked for
constants in <code>crates/onnx-ir/src/from_onnx.rs</code>.</p>
</li>
</ol>
<p>For example, the squeeze operation is defined in <code>crates/onnx-ir/src/node/squeeze.rs</code> and contains:</p>
<ul>
<li>A <code>squeeze_config</code> function that extracts axes from node attributes</li>
<li>A <code>squeeze_update_output</code> function that updates output dimensions by reducing input rank</li>
</ul>
<h4 id="within-burn-import"><a class="header" href="#within-burn-import">Within mabor-import</a></h4>
<ol>
<li>
<p>Create a new file named <code>&lt;operation_name&gt;.rs</code> in the <code>crates/mabor-import/src/mabor/node/</code>
directory. This file will define the structure and functionality of your new operation. By
convention, the necessary information for carrying out an operation is encapsulated within a
struct named <code>&lt;operation&gt;Node</code>. For the <code>Squeeze</code> operation, we defined a struct called
<code>SqueezeNode</code> that holds necessary information about the input tensor, output tensor, and axes
for the operation. <strong>If implementing a unary or binary operation, please see note below.</strong></p>
</li>
<li>
<p>The core of integrating a new operation involves implementing the <code>NodeCodegen</code> trait for your
node. This trait defines how the node generates code during the graph compilation process. The
implementation must provide methods to define input and output types, to generate the forward
pass code, and to encapsulate the node into the more general <code>Node</code> structure. Specifically:</p>
<ul>
<li><code>output_types</code> and <code>input_types</code> return the tensor (or element) types for the output and inputs
of the node, respectively.</li>
<li><code>forward</code> generates the Rust code that performs the operation during the execution phase. The
<code>quote!</code> macro is used to generate rust code. Ensure that this is syntactically correct using
Mabor code.</li>
<li><code>into_node</code> wraps the specific node in a general <code>Node</code> type, facilitating its inclusion in the
broader Mabor graph structure.</li>
</ul>
</li>
<li>
<p>This file is also where you would put <code>test_codegen_nodes()</code>, to make sure that the generated
code works within the Mabor library.</p>
</li>
</ol>
<p><strong>For unary and binary operations:</strong> The implementation of <code>NodeCodegen</code> is mostly implemented in
binary.rs and unary.rs, so each new operation only has to define a method to execute the function on
the input(s) token stream.</p>
<h3 id="step-3-registering-new-operations"><a class="header" href="#step-3-registering-new-operations">Step 3: Registering New Operations</a></h3>
<ol>
<li>In <code>crates/mabor-import/src/onnx/to_mabor.rs</code>, add the operation to the match statement in the
<code>into_mabor()</code> method:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ParsedOnnxGraph {
    pub fn into_mabor&lt;PS: PrecisionSettings + 'static&gt;(self) -&gt; MaborGraph&lt;PS&gt; {
        // ...
        for node in self.0.nodes {
            match node.node_type {
                // ...
                NodeType::Squeeze =&gt; graph.register(Self::squeeze_conversion(node)),
                // Add your new operation here
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li>Create a conversion function that creates an instance of your Mabor node:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn squeeze_conversion(node: Node) -&gt; SqueezeNode {
    let input = TensorType::from(node.inputs.first().unwrap());
    let output = TensorType::from(node.outputs.first().unwrap());
    let axes = squeeze_config(&amp;node);

    SqueezeNode::new(input, output, axes)
}
<span class="boring">}</span></code></pre></pre>
<p>This function extracts the necessary information from the ONNX node and passes it to your node's
constructor.</p>
<h3 id="step-4-create-a-config-function"><a class="header" href="#step-4-create-a-config-function">Step 4: Create a Config Function</a></h3>
<p>In <code>crates/onnx-ir/src/node/&lt;operation_name&gt;.rs</code>, create a config function that extracts
operation-specific parameters from the ONNX node:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn squeeze_config(curr: &amp;Node) -&gt; Vec&lt;i64&gt; {
    let axes = curr
        .attrs
        .iter()
        .filter_map(|(key, value)| {
            if key == "axes" {
                Some(value.clone().into_i64s())
            } else {
                None
            }
        })
        .next()
        .unwrap_or_else(Vec::new);

    match curr.inputs.first().unwrap().clone().ty {
        ArgType::Tensor(tensor) =&gt; tensor,
        _ =&gt; panic!("Only tensor input is valid"),
    };

    axes
}
<span class="boring">}</span></code></pre></pre>
<p>This config function is responsible for parsing the ONNX node attributes and extracting
operation-specific parameters. In this case, it extracts the "axes" attribute from the squeeze
operation.</p>
<h3 id="step-5-rank-inference"><a class="header" href="#step-5-rank-inference">Step 5: Rank Inference</a></h3>
<p>In <code>crates/onnx-ir/src/node/&lt;operation_name&gt;.rs</code>, implement a rank inference function that updates
the output rank based on the operation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn squeeze_update_output(node: &amp;mut Node) {
    // Extract axes information
    let axes = /* ... */;
    let input_rank = /* ... */;
    let output_rank = input_rank - axes.len();

    // Update output rank
    node.outputs[0].ty = ArgType::Tensor(TensorType {
        elem_type: node.inputs[0].ty.elem_type().clone(),
        rank: output_rank,
        static_shape: None,
    });
}
<span class="boring">}</span></code></pre></pre>
<p>Then register this function in <code>crates/onnx-ir/src/rank_inference.rs</code> by adding it to the match
statement:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn rank_inference(node: &amp;mut Node) {
    match node.node_type {
        // ...
        NodeType::Squeeze =&gt; squeeze_update_output(node),
        // Add your new operation here
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>rank_inference.rs</code> file is responsible for determining the output tensor rank for each node in
the graph.</p>
<p>If the rank remains unchanged, you can use helper functions like <code>same_as_input()</code> or
<code>same_as_input_broadcast()</code> instead of writing a custom update function.</p>
<h3 id="step-6-integrate-into-the-graph-building-process"><a class="header" href="#step-6-integrate-into-the-graph-building-process">Step 6: Integrate into the Graph Building Process</a></h3>
<p>When a new node type is introduced, it must be added to the <code>Node&lt;PS: PrecisionSettings&gt;</code> enum in
<code>crates/mabor-import/src/mabor/node/base.rs</code> and the <code>match_all!</code> macro in the same file.</p>
<p>The <code>Node</code> enum abstracts over different types of operations (nodes) within a network graph. Each
variant of the enum corresponds to a specific type of operation and encapsulates the
operation-specific data structures (like <code>SqueezeNode</code>) that were defined in step 2.</p>
<h3 id="step-7-add-newly-supported-op"><a class="header" href="#step-7-add-newly-supported-op">Step 7: Add Newly Supported Op!</a></h3>
<p>As a reward, add an extra check to <code>crates/mabor-import/SUPPORTED-ONNX-OPS.md</code>!</p>
<h3 id="lifting-constant-nodes"><a class="header" href="#lifting-constant-nodes">Lifting Constant Nodes</a></h3>
<p>If your operation takes inputs from constant nodes (such as weights in Conv1d, shape tensors in
Reshape, etc.), you need to add your operation's <code>NodeType</code> to the <code>LIFT_CONSTANTS_FOR_NODE_TYPES</code>
array in <code>crates/onnx-ir/src/from_onnx.rs</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const LIFT_CONSTANTS_FOR_NODE_TYPES: [NodeType; 16] = [
    NodeType::BatchNormalization,
    // other operations...
    NodeType::Squeeze,
    NodeType::Unsqueeze,
    // Add your operation here if it needs constants to be processed
];
<span class="boring">}</span></code></pre></pre>
<p>"Lifting" constants means converting Constant nodes into direct input values. This is similar to how
ONNX initializers work. For example, instead of having a separate Constant node providing weights to
a Convolution operation, the weights are directly embedded as values in the Convolution node's
inputs.</p>
<p>This transformation makes it easier to:</p>
<ol>
<li>Access the constant values during node configuration</li>
<li>Process operations like Conv1d that expect weights as direct inputs</li>
<li>Handle shape-defining inputs needed for operations like Reshape</li>
</ol>
<p>Without this, operations that need to extract configuration from constant inputs (such as shapes,
weights, or other parameters) would not work correctly because they wouldn't have direct access to
those constant values.</p>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>When implementing a new operator, there are several levels of testing to consider:</p>
<h3 id="unit-testing"><a class="header" href="#unit-testing">Unit Testing</a></h3>
<ul>
<li>
<p><strong>Node Configuration</strong>: Write unit tests for the <code>&lt;operation_name&gt;_config</code> function in
<code>crates/onnx-ir/src/node/&lt;operation_name&gt;.rs</code> to verify that it correctly extracts parameters from
ONNX nodes.</p>
</li>
<li>
<p><strong>Rank Inference</strong>: Test the <code>&lt;operation_name&gt;_update_output</code> function to ensure it correctly
computes output ranks.</p>
</li>
<li>
<p><strong>Code Generation</strong>: Test the Node implementation in <code>mabor-import</code> to verify that it generates
correct Rust code.</p>
</li>
</ul>
<h3 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h3>
<ul>
<li>Create small ONNX models that use your operator and test the end-to-end conversion process</li>
<li>Ensure the generated Rust code compiles and produces the expected outputs</li>
<li>Add these tests to <code>crates/mabor-import/onnx-tests/tests/test_onnx.rs</code></li>
</ul>
<h3 id="end-to-end-testing"><a class="header" href="#end-to-end-testing">End-to-End Testing</a></h3>
<ul>
<li>Test with realistic ONNX models that use your operator in conjunction with others</li>
<li>Verify that inputs and outputs match between the original ONNX model and the converted Mabor model</li>
<li>Include models that test edge cases (e.g., different input shapes, parameter combinations)</li>
</ul>
<p>Testing both the rank inference and node configuration is particularly important as these components
directly affect the correctness of the conversion process. Incorrect rank inference can lead to
mismatched tensor shapes, while incorrect configuration can cause runtime errors or incorrect
results.</p>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<ol>
<li><a href="https://pytorch.org/docs/stable/onnx.html">PyTorch to ONNX</a></li>
<li><a href="https://github.com/ENOT-AutoDL/onnx2torch">ONNX to PyTorch</a></li>
<li><a href="https://onnx.ai/onnx/intro/">ONNX Introduction</a></li>
<li><a href="https://onnx.ai/onnx/operators/index.html">ONNX Operators</a></li>
<li><a href="https://onnx.ai/onnx/api/classes.html">ONNX Protos</a></li>
<li><a href="https://github.com/onnx/optimizer">ONNX Optimizer</a></li>
<li><a href="https://github.com/lutzroeder/netron">Netron</a></li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="adding-a-new-operation-to-burn.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="adding-a-new-operation-to-burn.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
