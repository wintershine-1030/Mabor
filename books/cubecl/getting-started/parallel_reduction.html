<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Parallel Reduction - The CubeCL Book 🧊</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async="" src="../../../ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The CubeCL Book 🧊</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="parallel-reduction"><a class="header" href="#parallel-reduction">Parallel Reduction</a></h1>
<p>Before we dive into the code to implement parallel reduction, let's take a look at the constants that CubeCL provides to help us
write efficient parallel reduction kernels.</p>
<h2 id="cubecl-constants"><a class="header" href="#cubecl-constants">CubeCL Constants</a></h2>
<p>CubeCL is designed around - you guessed it - Cubes! More specifically, it's based on cuboids,
because not all axes are the same size. Since all compute APIs need to map to the hardware, which
are tiles that can be accessed using a 3D representation, our topology can easily be mapped to
concepts from other APIs.</p>
<div align="center">
<h3 id="cubecl---topology"><a class="header" href="#cubecl---topology">CubeCL - Topology</a></h3>
<img src="cubecl.drawio.svg" width="100%">
<br>
</div>
<br>
<p><em>A cube is composed of units, so a 3x3x3 cube has 27 units that can be accessed by their positions
along the x, y, and z axes. Similarly, a hyper-cube is composed of cubes, just as a cube is composed
of units. Each cube in the hyper-cube can be accessed by its position relative to the hyper-cube
along the x, y, and z axes. Hence, a hyper-cube of 3x3x3 will have 27 cubes. In this example, the
total number of working units would be 27 x 27 = 729.</em></p>
<h3 id="topology-equivalence"><a class="header" href="#topology-equivalence">Topology Equivalence</a></h3>
<p>Since all topology variables are constant within the kernel entry point, we chose to use the Rust
constant syntax with capital letters. Often when creating kernels, we don't always care about the
relative position of a unit within a cube along each axis, but often we only care about its position
in general. Therefore, each kind of variable also has its own axis-independent variable, which is
often not present in other languages, except WebGPU with <code>local_invocation_index</code>.</p>
<br>
<div class="table-wrapper"><table><thead><tr><th>CubeCL</th><th>CUDA</th><th>WebGPU</th></tr></thead><tbody>
<tr><td>CUBE_COUNT</td><td>N/A</td><td>N/A</td></tr>
<tr><td>CUBE_COUNT_X</td><td>gridDim.x</td><td>num_workgroups.x</td></tr>
<tr><td>CUBE_COUNT_Y</td><td>gridDim.y</td><td>num_workgroups.y</td></tr>
<tr><td>CUBE_COUNT_Z</td><td>gridDim.z</td><td>num_workgroups.z</td></tr>
<tr><td>CUBE_POS</td><td>N/A</td><td>N/A</td></tr>
<tr><td>CUBE_POS_X</td><td>blockIdx.x</td><td>workgroup.x</td></tr>
<tr><td>CUBE_POS_Y</td><td>blockIdx.y</td><td>workgroup.y</td></tr>
<tr><td>CUBE_POS_Z</td><td>blockIdx.z</td><td>workgroup.z</td></tr>
<tr><td>CUBE_DIM</td><td>N/A</td><td>N/A</td></tr>
<tr><td>CUBE_DIM_X</td><td>blockDim.x</td><td>workgroup_size.x</td></tr>
<tr><td>CUBE_DIM_Y</td><td>blockDim.y</td><td>workgroup_size.y</td></tr>
<tr><td>CUBE_DIM_Z</td><td>blockDim.z</td><td>workgroup_size.z</td></tr>
<tr><td>UNIT_POS</td><td>N/A</td><td>local_invocation_index</td></tr>
<tr><td>UNIT_POS_X</td><td>threadIdx.x</td><td>local_invocation_id.x</td></tr>
<tr><td>UNIT_POS_Y</td><td>threadIdx.y</td><td>local_invocation_id.y</td></tr>
<tr><td>UNIT_POS_Z</td><td>threadIdx.z</td><td>local_invocation_id.z</td></tr>
<tr><td>PLANE_DIM</td><td>warpSize</td><td>subgroup_size</td></tr>
<tr><td>ABSOLUTE_POS</td><td>N/A</td><td>N/A</td></tr>
<tr><td>ABSOLUTE_POS_X</td><td>N/A</td><td>global_id.x</td></tr>
<tr><td>ABSOLUTE_POS_Y</td><td>N/A</td><td>global_id.y</td></tr>
<tr><td>ABSOLUTE_POS_Z</td><td>N/A</td><td>global_id.z</td></tr>
</tbody></table>
</div>
<h2 id="parallel-reduction-example"><a class="header" href="#parallel-reduction-example">Parallel Reduction Example</a></h2>
<p>Remembering the previous example, we will now implement a parallel reduction using CubeCL. The goal is to reduce a 2D matrix into a 1D vector by summing the elements of each row. Where can we parallelize this operation? We can parallelize the reduction of each row, allowing each thread to compute the sum of a row independently. We need to change the launch parameters to set the CubeDim to launch multiple invocation in parallel and we can just remove the outer loop and use the <code>UNIT_POS_X</code> to access the rows of the input tensor. Please note that it is important to worry about data races when parallelizing operations, so we need to ensure that each invocation writes to a different position in the output tensor, because each invocation run in parallel.</p>
<pre><code class="language-rust ignore"><span class="boring">use std::marker::PhantomData;
</span><span class="boring">
</span><span class="boring">use cubecl::benchmark::{Benchmark, TimingMethod};
</span><span class="boring">use cubecl::{future, prelude::*};
</span><span class="boring">use cubecl_example::gpu_tensor::GpuTensor; // Change to the path of your own module containing the GpuTensor
</span><span class="boring">
</span><span class="boring">pub struct ReductionBench&lt;R: Runtime, F: Float + CubeElement&gt; {
</span><span class="boring">    input_shape: Vec&lt;usize&gt;,
</span><span class="boring">    client: ComputeClient&lt;R::Server, R::Channel&gt;,
</span><span class="boring">    _f: PhantomData&lt;F&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;R: Runtime, F: Float + CubeElement&gt; Benchmark for ReductionBench&lt;R, F&gt; {
</span><span class="boring">    type Input = GpuTensor&lt;R, F&gt;;
</span><span class="boring">    type Output = GpuTensor&lt;R, F&gt;;
</span><span class="boring">
</span><span class="boring">    fn prepare(&amp;self) -&gt; Self::Input {
</span><span class="boring">        GpuTensor::&lt;R, F&gt;::arange(self.input_shape.clone(), &amp;self.client)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn name(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}-reduction-{:?}", R::name(&amp;self.client), self.input_shape).to_lowercase()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn sync(&amp;self) {
</span><span class="boring">        future::block_on(self.client.sync())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn execute(&amp;self, input: Self::Input) -&gt; Self::Output {
</span><span class="boring">        let output_shape: Vec&lt;usize&gt; = vec![self.input_shape[0]];
</span>        let output = GpuTensor::&lt;R, F&gt;::empty(output_shape, &amp;self.client);

        unsafe {
            reduce_matrix::launch_unchecked::&lt;F, R&gt;(
                &amp;self.client,
                CubeCount::Static(1, 1, 1),
                CubeDim::new(self.input_shape[0] as u32, 1, 1), // Add parallelization on the first dimension
                input.into_tensor_arg(1),
                output.into_tensor_arg(1),
            );
        }

        output
    }
}

#[cube(launch_unchecked)]
fn reduce_matrix&lt;F: Float&gt;(input: &amp;Tensor&lt;F&gt;, output: &amp;mut Tensor&lt;F&gt;) {
    let mut acc = F::new(0.0f32);
    for i in 0..input.shape(1) {
        acc += input[UNIT_POS_X * input.stride(0) + i];
    }
    output[UNIT_POS_X] = acc;
}
<span class="boring">
</span><span class="boring">pub fn launch&lt;R: Runtime, F: Float + CubeElement&gt;(device: &amp;R::Device) {
</span><span class="boring">    let client = R::client(&amp;device);
</span><span class="boring">
</span><span class="boring">    let bench1 = ReductionBench::&lt;R, F&gt; {
</span><span class="boring">        input_shape: vec![512, 8 * 1024],
</span><span class="boring">        client: client.clone(),
</span><span class="boring">        _f: PhantomData,
</span><span class="boring">    };
</span><span class="boring">    let bench2 = ReductionBench::&lt;R, F&gt; {
</span><span class="boring">        input_shape: vec![128, 32 * 1024],
</span><span class="boring">        client: client.clone(),
</span><span class="boring">        _f: PhantomData,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for bench in [bench1, bench2] {
</span><span class="boring">        println!("{}", bench.name());
</span><span class="boring">        println!("{}", bench.run(TimingMethod::System));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    launch::&lt;cubecl::wgpu::WgpuRuntime, f32&gt;(&amp;Default::default());
</span><span class="boring">}</span></code></pre>
<h2 id="the-results"><a class="header" href="#the-results">The Results</a></h2>
<p>Now that we have improved parallelism, the kernel is up to 70x faster for the first shape and up to 25x faster for the second shape. Why is the first shape faster than the second? Even though the two shape have the same number of elements, the first shape has more rows than the second shape, which means that more invocations can be used to compute the reduction in parallel. The second shape has fewer rows, so fewer invocations are available to compute the reduction in parallel.</p>
<pre><code>wgpu&lt;wgsl&gt;-reduction-[512, 8192]

―――――――― Result ―――――――――
  Timing      system
  Samples     10
  Mean        3.369ms
  Variance    48.000ns
  Median      3.321ms
  Min         3.177ms
  Max         4.011ms
―――――――――――――――――――――――――
wgpu&lt;wgsl&gt;-reduction-[128, 32768]

―――――――― Result ―――――――――
  Timing      system
  Samples     10
  Mean        8.713ms
  Variance    5.069µs
  Median      8.507ms
  Min         5.963ms
  Max         12.301ms
―――――――――――――――――――――――――
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="benchmark.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="vectorized_reduction.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="benchmark.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="vectorized_reduction.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
