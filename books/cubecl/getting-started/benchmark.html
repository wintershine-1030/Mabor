<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Benchmark - The CubeCL Book 🧊</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async="" src="../../../ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The CubeCL Book 🧊</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="benchmarking-reduction"><a class="header" href="#benchmarking-reduction">Benchmarking reduction</a></h1>
<p>Now that we have a basic understanding of how to perform a reduction operation, let's benchmark it to see how it performs in terms of speed and efficiency.</p>
<h2 id="benchmarking-struct"><a class="header" href="#benchmarking-struct">Benchmarking struct</a></h2>
<p>For benchmarking, we will create a struct that holds the necessary information for the benchmark, such as the input shape, device, and client. This struct will be used to run the benchmark tests and configure the benchmarking environment. Please note that the <code>Runtime</code> and <code>Float</code> traits are used to make the benchmark generic over different CubeCL runtimes and floating-point types. A <code>PhantomData</code> is used to indicate that the struct holds a type parameter <code>F</code> without actually storing a value of that type, which is useful for generic programming in Rust, for more information see the <a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html">Rust documentation</a> and in our case allows us to easily change the type of float used in the benchmark.</p>
<pre><code class="language-rust ignore">use std::marker::PhantomData;

use cubecl::benchmark::{Benchmark, TimingMethod};
use cubecl::{future, prelude::*};
use cubecl_example::gpu_tensor::GpuTensor; // Change to the path of your own module containing the GpuTensor

pub struct ReductionBench&lt;R: Runtime, F: Float + CubeElement&gt; {
    input_shape: Vec&lt;usize&gt;,
    client: ComputeClient&lt;R::Server, R::Channel&gt;,
    _f: PhantomData&lt;F&gt;,
}</code></pre>
<h2 id="implementing-the-benchmark-trait"><a class="header" href="#implementing-the-benchmark-trait">Implementing the benchmark trait</a></h2>
<p>To benchmark a CubeCL kernel, it is recommended to implement the <code>Benchmark</code> trait that defines the necessary methods for preparing, executing, and synchronizing the benchmark because GPUs are asynchronous and most benchmarking tools will not wait for the GPU to finish executing the kernel before measuring the time it takes to execute it with a sync.</p>
<pre><code class="language-rust ignore">/// Benchmark trait.
pub trait Benchmark {
    /// Benchmark input arguments.
    type Input: Clone;
    /// The benchmark output.
    type Output;

    /// Prepare the benchmark, run anything that is essential for the benchmark, but shouldn't
    /// count as included in the duration.
    ///
    /// # Notes
    ///
    /// This should not include warmup, the benchmark will be run at least one time without
    /// measuring the execution time.
    fn prepare(&amp;self) -&gt; Self::Input;

    /// Execute the benchmark and returns the logical output of the task executed.
    ///
    /// It is important to return the output since otherwise deadcode optimization might optimize
    /// away code that should be benchmarked.
    fn execute(&amp;self, input: Self::Input) -&gt; Self::Output;

    /// Name of the benchmark, should be short and it should match the name
    /// defined in the crate Cargo.toml
    fn name(&amp;self) -&gt; String;

    /// Wait for computation to complete.
    fn sync(&amp;self);
}
</code></pre>
<p>In the <code>prepare</code> method, we will create the input data and return a <code>GpuTensor</code> that will be used in the <code>execute</code> method. The <code>execute</code> method will launch the kernel and the <code>sync</code> method will wait for the GPU to finish executing the kernel before measuring the time it takes to execute it. Don't forget to add the function that we want to benchmark.</p>
<pre><code class="language-rust ignore">use std::marker::PhantomData;

use cubecl::benchmark::{Benchmark, TimingMethod};
use cubecl::{future, prelude::*};
use cubecl_example::gpu_tensor::GpuTensor; // Change to the path of your own module containing the GpuTensor

pub struct ReductionBench&lt;R: Runtime, F: Float + CubeElement&gt; {
    input_shape: Vec&lt;usize&gt;,
    client: ComputeClient&lt;R::Server, R::Channel&gt;,
    _f: PhantomData&lt;F&gt;,
}

impl&lt;R: Runtime, F: Float + CubeElement&gt; Benchmark for ReductionBench&lt;R, F&gt; {
    type Input = GpuTensor&lt;R, F&gt;;
    type Output = GpuTensor&lt;R, F&gt;;

    fn prepare(&amp;self) -&gt; Self::Input {
        GpuTensor::&lt;R, F&gt;::arange(self.input_shape.clone(), &amp;self.client)
    }

    fn name(&amp;self) -&gt; String {
        format!("{}-reduction-{:?}", R::name(&amp;self.client), self.input_shape).to_lowercase()
    }

    fn sync(&amp;self) {
        future::block_on(self.client.sync())
    }

    fn execute(&amp;self, input: Self::Input) -&gt; Self::Output {
        let output_shape: Vec&lt;usize&gt; = vec![self.input_shape[0]];
        let output = GpuTensor::&lt;R, F&gt;::empty(output_shape, &amp;self.client);

        unsafe {
            reduce_matrix::launch_unchecked::&lt;F, R&gt;(
                &amp;self.client,
                CubeCount::Static(1, 1, 1),
                CubeDim::new(1, 1, 1),
                input.into_tensor_arg(1),
                output.into_tensor_arg(1),
            );
        }

        output
    }
}

#[cube(launch_unchecked)]
fn reduce_matrix&lt;F: Float&gt;(input: &amp;Tensor&lt;F&gt;, output: &amp;mut Tensor&lt;F&gt;) {
    for i in 0..input.shape(0) {
        let mut acc = F::new(0.0f32);
        for j in 0..input.shape(1) {
            acc += input[i * input.stride(0) + j];
        }
        output[i] = acc;
    }
}</code></pre>
<h2 id="running-the-benchmark"><a class="header" href="#running-the-benchmark">Running the benchmark</a></h2>
<p>Now that we have implemented the <code>Benchmark</code> trait, we can run the benchmark using the <code>Benchmark::run</code> method. This method will execute the benchmark and return the time it took to complete it.</p>
<pre><code class="language-rust ignore"><span class="boring">use std::marker::PhantomData;
</span><span class="boring">
</span><span class="boring">use cubecl::benchmark::{Benchmark, TimingMethod};
</span><span class="boring">use cubecl::{future, prelude::*};
</span><span class="boring">use cubecl_example::gpu_tensor::GpuTensor; // Change to the path of your own module containing the GpuTensor
</span><span class="boring">
</span><span class="boring">pub struct ReductionBench&lt;R: Runtime, F: Float + CubeElement&gt; {
</span><span class="boring">    input_shape: Vec&lt;usize&gt;,
</span><span class="boring">    client: ComputeClient&lt;R::Server, R::Channel&gt;,
</span><span class="boring">    _f: PhantomData&lt;F&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;R: Runtime, F: Float + CubeElement&gt; Benchmark for ReductionBench&lt;R, F&gt; {
</span><span class="boring">    type Input = GpuTensor&lt;R, F&gt;;
</span><span class="boring">    type Output = GpuTensor&lt;R, F&gt;;
</span><span class="boring">
</span><span class="boring">    fn prepare(&amp;self) -&gt; Self::Input {
</span><span class="boring">        GpuTensor::&lt;R, F&gt;::arange(self.input_shape.clone(), &amp;self.client)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn name(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}-reduction-{:?}", R::name(&amp;self.client), self.input_shape).to_lowercase()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn sync(&amp;self) {
</span><span class="boring">        future::block_on(self.client.sync())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn execute(&amp;self, input: Self::Input) -&gt; Self::Output {
</span><span class="boring">        let output_shape: Vec&lt;usize&gt; = vec![self.input_shape[0]];
</span><span class="boring">        let output = GpuTensor::&lt;R, F&gt;::empty(output_shape, &amp;self.client);
</span><span class="boring">
</span><span class="boring">        unsafe {
</span><span class="boring">            reduce_matrix::launch_unchecked::&lt;F, R&gt;(
</span><span class="boring">                &amp;self.client,
</span><span class="boring">                CubeCount::Static(1, 1, 1),
</span><span class="boring">                CubeDim::new(1, 1, 1),
</span><span class="boring">                input.into_tensor_arg(1),
</span><span class="boring">                output.into_tensor_arg(1),
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        output
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cube(launch_unchecked)]
</span><span class="boring">fn reduce_matrix&lt;F: Float&gt;(input: &amp;Tensor&lt;F&gt;, output: &amp;mut Tensor&lt;F&gt;) {
</span><span class="boring">    for i in 0..input.shape(0) {
</span><span class="boring">        let mut acc = F::new(0.0f32);
</span><span class="boring">        for j in 0..input.shape(1) {
</span><span class="boring">            acc += input[i * input.stride(0) + j];
</span><span class="boring">        }
</span><span class="boring">        output[i] = acc;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn launch&lt;R: Runtime, F: Float + CubeElement&gt;(device: &amp;R::Device) {
    let client = R::client(&amp;device);

    let bench1 = ReductionBench::&lt;R, F&gt; {
        input_shape: vec![512, 8 * 1024],
        client: client.clone(),
        _f: PhantomData,
    };
    let bench2 = ReductionBench::&lt;R, F&gt; {
        input_shape: vec![128, 32 * 1024],
        client: client.clone(),
        _f: PhantomData,
    };

    for bench in [bench1, bench2] {
        println!("{}", bench.name());
        println!("{}", bench.run(TimingMethod::System));
    }
}

fn main() {
    launch::&lt;cubecl::wgpu::WgpuRuntime, f32&gt;(&amp;Default::default());
}</code></pre>
<h2 id="the-results"><a class="header" href="#the-results">The Results</a></h2>
<p>When you run the above code, it will execute the reduction benchmark for two different input shapes and print the results to the console. The output will look something like this:</p>
<pre><code>wgpu&lt;wgsl&gt;-reduction-[512, 8192]

―――――――― Result ―――――――――
  Timing      system
  Samples     10
  Mean        240.730ms
  Variance    1.595µs
  Median      240.310ms
  Min         239.974ms
  Max         244.374ms
―――――――――――――――――――――――――
wgpu&lt;wgsl&gt;-reduction-[128, 32768]

―――――――― Result ―――――――――
  Timing      system
  Samples     10
  Mean        241.018ms
  Variance    1.068µs
  Median      240.943ms
  Min         239.734ms
  Max         243.782ms
―――――――――――――――――――――――――
</code></pre>
<p>As we will see in the next chapter, our time is not that good, but it is expected because we are using a very simple kernel that does not take advantage of the GPU parallelism. In the next chapter, we will see how to optimize our kernel to take advantage of the GPU parallelism and improve the performance of our reduction operation.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="simple_reduction.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="parallel_reduction.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="simple_reduction.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="parallel_reduction.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
